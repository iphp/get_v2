# github.com/vpei/Free-Node-Merge
# Description: Automatically Build SSR for OpenWrt
# Cron: min (0 - 59) / hour (0 - 23) / day of month (1 - 31) / month (1 - 12) / day of week (0 - 6)(Sunday - Saturday)
# Source code repository: https://github.com/openwrt/openwrt / Branch: master
#========================================================================================================================

name: Publish-Node-To-Ipfs-2021

# Controls when the action will run. 
on:
  push:
    branches: [ main ]
  schedule:
    - cron: '0 */3 * * *'
  workflow_dispatch:

jobs:
  Build:
    runs-on: ubuntu-latest
    steps:
      - name: 'Set System Timezone'
        run: 
          sudo timedatectl set-timezone Asia/Shanghai

      - name: Checkout
        uses: actions/checkout@v2

      - name: 'Set up Python'
        uses: actions/setup-python@v1
        with:
           python-version: 3.7

      - name: 'Install requirements'
        run: |
          #pip install requests
          #python -m pip install -U wheel
          #pip install qqwry-py3
          pip install -r ./res/requirements.txt

      - name: 'Update and merge node from url'
        id: update
        env:
          RESURL: ${{ secrets.RESURL }}
        run: 
          python main.py update
          echo "::set-output name=status::success"

      - name: 'Update node ip-address info'
        id: ipdomain
        env:
          RESURL: ${{ secrets.RESURL }}
        run: 
          python main.py ipdomain
          echo "::set-output name=status::success"

      - name: 'Compare new file with old file MD5'
        id: diff
        run: |
          file1=./res/vpei-new.txt
          file2=./res/vpei.txt
          #dataline1=$(< $file1)
          dataline1=$(md5sum $file1|cut -d ' ' -f1)
          echo $dataline1
          #dataline2=$(< $file2)
          dataline2=$(md5sum $file2|cut -d ' ' -f1)
          echo $dataline2
          if [ "$dataline1" == "$dataline2" ];then
            rm $file1
            echo "Both file are same"
            echo "::set-output name=status::noupdate"
          else
            mv $file1 $file2
            echo "Both file are different"
            echo "::set-output name=status::success"
          fi
          echo "::set-output name=status::success"

      - name: 'Send telegram message on push'
        env:
          TELEGRAM_TO: ${{ secrets.TELEGRAM_TO }}
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
        uses: appleboy/telegram-action@master
        if: steps.diff.outputs.status == 'success'  && env.TELEGRAM_TO != ''  && env.TELEGRAM_TOKEN != '' && !cancelled()
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          message: |
             Mixed Nodes-1: http://143.198.135.169:8080/ipns/k51qzi5uqu5dlfnig6lej7l7aes2d5oed6a4435s08ccftne1hq09ac1bulz2f/

             Mixed Nodes-2: https://gateway.ipfs.io/ipns/k51qzi5uqu5dlfnig6lej7l7aes2d5oed6a4435s08ccftne1hq09ac1bulz2f/

      - name: 'Commit files first'
        if: steps.diff.outputs.status == 'success' && !cancelled()
        run: |
          rm -rf ./cls/__pycache__
          rm -rf ./ip/__pycache__
          rm -rf ./ping3/__pycache__
          git config --global user.email actions@github.com
          git config --global user.name "GitHub Actions"
          git pull
          git add .
          git commit -m "Automatic upgrade by robot at $(date +"%Y.%m.%d.%H%M")" -a

      - name: 'Push changes first'
        uses: ad-m/github-push-action@master
        if: steps.diff.outputs.status == 'success' && !cancelled()
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: main
          #branch: ${{ github.ref }}

      - name: 'Upload Files To Ipfs Network'
        id: ipfs
        env:
          PEERID: ${{ secrets.PEERID }}
          PRIVKEY: ${{ secrets.PRIVKEY }}
          CID: cid
        if: steps.ipdomain.outputs.status == 'success' && env.PEERID != '' && env.PRIVKEY != ''
        run: |
          #git clone https://github.com/letseeqiji/oneinstall.git
          #cd oneinstall/golang
          #sh goinstall.sh
          go version
          #git clone https://github.com/ipfs/go-ipfs.git
          #cd go-ipfs
          #make install
          # wget http://dweb.link/ipfs/QmZWbdDNEMGpTYNA9LhtyA2E5Z6weVCcAqKpWYddzUUfru/go-ipfs/ipfs -O ./ipfs/ipfs
          chmod 7777 ./ipfs/ipfs
          #wget http://dweb.link/ipfs/QmZWbdDNEMGpTYNA9LhtyA2E5Z6weVCcAqKpWYddzUUfru/go-ipfs/install.sh -O install.sh
          chmod 7777 ./ipfs/install.sh
          sh ./ipfs/install.sh
          #ipfs init
          mkdir /home/runner/.ipfs
          cp -r ./ipfs/config/* /home/runner/.ipfs
          sed -i 's/vpeiPEERID/${{ secrets.PEERID }}/g' /home/runner/.ipfs/config
          sed -i 's/vpeiPRIVKEY/${{ env.PRIVKEY }}/g' /home/runner/.ipfs/config
          #cp -r /home/runner/.ipfs config
          #cp -f /home/runner/.ipfs/config ./config
          #cd /home/runner/.ipfs
          #ls

          ipfs id
          file1=./ipfs/tmp/001.out
          nohup ipfs add -r ./out >$file1 &
          sleep 5
          dataline1=$(< $file1)
          echo $dataline1

          echo  下行数字50需要根据文件发布的目录调整./out，目录长度增长，50数字增加。
          #echo ${dataline1: -50}
          CID=${dataline1: -50}
          echo $CID
          echo
          CID=${CID% *}
          echo ID:$CID
          # ipfs pin add $CID
          
          # 运行ipfs软件
          nohup ipfs daemon >$file1 &
          sleep 60
          file1=./ipfs/tmp/tmp.out
          # 对发布的文件进行加载, CID从001.out文件获取或直接传递
          nohup sudo wget http://127.0.0.1:8080/ipfs/$CID/ -O $file1 >$file1 &
          sleep 2
          nohup sudo wget http://127.0.0.1:8080/ipfs/$CID/node.txt -O $file1 >$file1 &
          sleep 2
          nohup sudo wget http://127.0.0.1:8080/ipfs/$CID/nodecn.txt -O $file1 >$file1 &
          sleep 2
          nohup sudo wget http://127.0.0.1:8080/ipfs/$CID/clash.yaml -O $file1 >$file1 &
          sleep 2
          nohup sudo wget http://127.0.0.1:8080/ipfs/$CID/openclash.yaml -O $file1 >$file1 &

          sleep 60
          # 对网络文件进行循环加载
          python ./ipfs.py ipfs $CID

          #echo 关闭进程 ipfs #kill ipfs
          ps -A
          ipfs shutdown 
          sleep 60
          ps -A

          ipfs name publish /ipfs/$CID --allow-offline=true --lifetime=24h
          file1=./ipfs/tmp/002.out
          dataline1=$(< $file1)
          echo $dataline1
          sleep 10

          ipfs id
          ipfs files cp /ipfs/$CID "/clash"
          sleep 10

          file1=./ipfs/tmp/001.out
          nohup ipfs daemon >$file1 &
          dataline1=$(< $file1)
          echo $dataline1
          # cp -r -f /home/runner/.ipfs ./config2
          echo "::set-output name=status::success"

      - name: 'Publish Files To Ipfs Network'
        id: publish
        env:
          PUBLISHID: ${{ secrets.PUBLISHID }}
        if: steps.ipfs.outputs.status == 'success' && env.PUBLISHID != '' && !cancelled()
        run: |
          # sudo rm -rf ./install1 ./install2 ./install3
          # sudo cp -f ./res/README.md ./README.md
          # 需要安装sed 软件
          # sudo sed -i 's/ipfs_auto_url/${{ secrets.RESURL }}code.txt\n\n${{ secrets.RESURL }}clash\n\n${{ secrets.RESURL }}openclash/g' ./README.md

          echo 关闭进程 ipfs #kill ipfs
          ps -A
          ipfs shutdown 
          sleep 60
          ps -A
          file1=./ipfs/tmp/003.out
          nohup ipfs daemon >$file1 &
          sleep 60
          
          # 说明：nohup加在一个命令的最前面，表示不挂断的运行命令
          # -u 表示实时输出到.out
          #&加在一个命令的最后面，表示这个命令放在后台执行
          #echo 正在执行ipfs add -r ./ipfs
          #for /f "tokens=2" %%i in ('ipfs add -r ./ipfs') do set val=%%i
          #echo 正在执行ipfs files cp /ipfs/%val% "/openclash"
          #chmod 7777 ./ipfs/ipfs.service
          #cd /lib/systemd/system
          #ls
          #chmod 7777 /lib/systemd/system
          #cp ./ipfs.service /lib/systemd/system/
          #ipfs id
          #sudo systemctl enable ipfs.service
          #ipfs id
          #开启ipfs服务
          #sudo systemctl start ipfs.service
          #ipfs id
          #停止服务
          #sudo systemctl stop ipfs.service
          # ipfs id

          python ./ipfs.py ipns
          echo "::set-output name=status::success"

      - name: 'Commit files Second for readMe file'
        if: steps.publish.outputs.status == 'success' && !cancelled()
        run: |
          rm -rf ./cls/__pycache__
          rm -rf ./ip/__pycache__
          rm -rf ./ping3/__pycache__
          git config --global user.email actions@github.com
          git config --global user.name "GitHub Actions"
          git pull
          git add .
          git commit -m "Automatic upgrade by robot at $(date +"%Y.%m.%d.%H%M")" -a

      - name: 'Push changes Second for readMe file'
        uses: ad-m/github-push-action@master
        if: steps.publish.outputs.status == 'success' && !cancelled()
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          branch: main
          #branch: ${{ github.ref }}

      - name: 'Delete older workflow runs and artifacts'
        uses: Mattraks/delete-workflow-runs@main
        if: steps.publish.outputs.status == 'success' && !cancelled()
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          repository: ${{ github.repository }}
          retain_days: 7
          keep_minimum_runs: 20

      - name: 'Send telegram message on push'
        env:
          TELEGRAM_TO: ${{ secrets.TELEGRAM_TO }}
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
        uses: appleboy/telegram-action@master
        if: steps.publish.outputs.status == 'success'  && env.TELEGRAM_TO != ''  && env.TELEGRAM_TOKEN != '' && !cancelled()
        with:
          to: ${{ secrets.TELEGRAM_TO }}
          token: ${{ secrets.TELEGRAM_TOKEN }}
          message: |
             Publish files To ipfs network is finished.

      - name: 'Waiting for ipfs release'
        env:
          PUBLISHID: ${{ secrets.PUBLISHID }}
        if: steps.publish.outputs.status == 'success' && env.PUBLISHID != '' && !cancelled()
        run: |
          sleep 10
          echo First
          sleep 10
          echo Second
